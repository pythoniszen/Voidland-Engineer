# VOIDLAND ENGINEER
#### Video Demo: <https://www.youtube.com/watch?v=SrNsun7WVoQ>
#### Description:
##### Installation Instructions:
  Included in this project folder is the source code to Voidland Engineer, as well as the compressed zip file for the game itself. Unzip the the zip files' contents and open the extracted file. Click the .exe file inside of this folder to launch the game. After this, you are set to play Voidland Engineer! Do not remove any files from this folder to ensure the game will launch and run as intended.
##### About:
  Voidland Engineer is a 2D sidescrolling adventure inspired by old school style games such as the original Super Mario Bros. A lot of love was put in to this project, in which almost all components were made by me (Nathan Lusk). All music, sounds, artwork, and most of the code was created by me. When I was younger, I used to make games in the programming language Scratch. I was never able to make exactly what I wanted to create, as I was quite young at the time. I thought it would be fun, as well as a good learning experience, to revisit coding games and to make a game without using an engine or any pre-made art. During Harvard's CS50, I was introduced to the Love2D framework for Lua. I decided this framework would be the perfect fit for what I was going for. As well as the Love framework, I also used two libraries/modules in order to simulate classes and timers in Lua out of convenience as well as development time constraints. I learned the basics of Love2D and used several coding concepts from Sheepolution's How to Love guide, as reccomended by CS50. That guide was a very useful introduction to the framework, which I strongly reccomend to anyone wanting to learn Love2d! (Links to frameworks, modules, and educational material are provided below in references section.)
##### Development Details/ Design:
  Voidland engineer utilizes Love2D in order to use Lua in such a way where there is a main game loop declared in the main.lua file. This file contains three main functions: love.load(), love.update(), and love.draw(). This main script is executed repeatedly in order to create a 2D game. The love.load() function loads all of the assets for the game and stores them as variables, which can be called upon later in love.update() and love.draw(). The love.update() function updates the state of the variables in the game using logic/conditional statements to define what will happen in game. There are built in functions in Love which allow you to receive user input and respond to it with a range of possibilities and outcomes. This input data can be used for instance in love.update to update certain elements in the game such as coin count. The love.draw() function is what draws the visual data for the game based on whatever happened in love.update().
  All of the other files are linked back to main, and/or one another in order to work with each other's code. This is done by using the "require" keyword at the top of each file. The helpers.lua file holds the map data for each level in the game as well as a collision detection function which is called upon by other files. The other .lua files are simply classes created using the "classic" library. For instance, emushroomclass.lua represents a class for all of the mushroom enemies in the game. This design choice was selected for in order to reduce the size of main.lua. If not split into class files, main.lua would be far too bulky and hard to navigate through. This is a nice way of organizing code and makes it easier to alter/keep track of. The art file contains artwork, vleaudiofx contains sounds for the game, the -master files contain the modules/libraries used, and the compressed zip contains the game file itself.
  Some of the main features coded into the game are a gravity/physics system, projectile weapons, doors/keys, a start menu with buttons, two enemy types, an item shop/coins, a power-up item, a cutscene, NPC's with dialogue, sound effects, and a boss fight. These features were selected based on what was the most essential to make the experience feel complete. The goal was to make a game that was minimal, but nonetheless a finished product. For instance, I almost designed three enemy types. This was decided aginst in the final product because it did not seem like a necessity due to the game only having three different maps. These features were implemented using logic/conditions statements as well as using timers to trigger the exact timing of certain events.
  This game was a ton of fun to create and I learned a lot about coding during this project. I was able to successfuly pick up a language that I had never used before, and design and create a fully functional game for my first official coding project. Thank you to CS50 for the amazing introduction to computer science!
##### Connect with me:
https://github.com/pythoniszen
##### References:
https://cs50.harvard.edu/
https://github.com/rxi/classic
https://github.com/a327ex/chrono
https://sheepolution.com/learn/book/contents